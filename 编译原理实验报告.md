# 编译原理实验报告

##### 曹小川  张骥轩  朱子秋



## 前言

本次实验完成了一个C语言的编译器，能够分析C语言的语法，并将其编译至`LLVM IR`，最后再编译至目标代码（ .o 文件）。

### 运行环境

编程环境：ubuntu

编程语言：C++

IDE : Vscode

构建工具：CMake

### 依赖项

1. Flex & Bison

   使用flex和bison生成词法分析器和语法分析器。

2. LLVM-14

   使用LLVM来完成语义分析、中间代码生成、编译器优化、目标代码生成。

### 分工

曹小川：完成`c.l`,`c.y`,`CodeGenerator`,`AST.h`参与编写`AST.h`

朱子秋：完成`AST.h`多数代码

张骥轩：完成`c.l`,`c.y`，参与编写`AST.h`



## 词法分析

Flex（Fast Lexical Analyzer Generator）是一个用于生成词法分析器的工具。它是GNU项目中的一部分。

Flex接受一组正则表达式和对应的动作规则作为输入，然后生成一个C/C++源代码文件，该文件实现了一个高效的词法分析器。词法分析器用于将输入文本流分解为一系列的标记（token），这些标记可以在编译器、解释器和其他语言处理工具中用于进一步的语法分析。

Flex的工作流程如下：

1. 用户定义一系列的正则表达式和与之对应的动作规则。这些规则描述了词法分析器如何识别和处理不同的标记。
2. Flex读取这些规则，并根据规则生成一个有限状态自动机（Finite State Machine，FSM）。
3. Flex根据有限状态自动机生成C/C++源代码文件，其中包含了识别和处理输入文本流的逻辑。
4. 用户可以将生成的源代码文件编译为可执行文件，从而得到一个高效的词法分析器。



flex的输入文件由三段构成：

```c++
definition
%%
rules
%%
user's code
```

1. 定义部分（Definition）： 定义部分用于声明全局变量、包含头文件和宏定义等。这一部分通常位于代码的开头，并且以`%{`和`%}`包围起来。在定义部分中，你可以定义和声明词法分析器所需的全局变量、常量、宏以及需要引入的头文件。
2. 规则部分（Rules）： 规则部分是Flex中最重要的部分，它包含了一系列的正则表达式和与之对应的动作规则。每个规则由一个正则表达式和一个与之关联的动作组成。当输入流匹配某个规则时，对应的动作将被执行。规则部分使用特殊的语法来定义正则表达式和动作规则。通常，规则部分位于`%%`标记之间。
3. 用户代码部分（User's Code）： 用户代码部分用于编写自定义的C/C++代码，通常用于实现词法分析器生成的动作逻辑之外的其他功能。在这部分中，你可以编写与词法分析器相关的辅助函数、处理分析器返回结果的逻辑、与其他模块进行交互等。用户代码部分位于`%%`标记之后，即规则部分的后面。

#### 定义部分

定义部分包括了必须插到第一部分 %{ 和 %} 之间的C代码，包括头文件定义和逃逸字符返回函数

```c++
%{
#include<stdio.h>
#include <string>
#include <iostream>
char SecondChar(char ch);
%}
```



#### 规则部分

**直接匹配字符和关键字**

```c++
/*keywords*/
"break"         { return BREAK;    }
"else"          { return ELSE;     }
"if"            { return IF;       }
"return"        { return RETURN;   }
"while"         { return WHILE;    }
"for"           { return FOR;      }
/*operations*/
"&&"            { return AND; }
"||"            { return OR; }
"<="            { return LE; }
">="            { return GE; }
"=="            { return EQ; }
"!="            { return NE; }
";"             { return SEMICOLON; }
"{"             { return LBRACE; }
"}"             { return RBRACE; }
","             { return COMMA; }
":"             { return COLON; }
"="             { return ASSIGN; }
"("             { return LPARENT; }
")"             { return RPARENT; }
"["             { return LBRACKET; }
"]"             { return RBRACKET; }
"."             { return DOT; }
"&"             { return BITAND; }
"!"             { return NOT; }
"~"             { return BITNOT; }
"-"             { return SUB; }
"+"             { return PLUS; }
"*"             { return MUL; }
"/"             { return DIV; }
"%"             { return MOD; }
"<"             { return LT; }
">"             { return GT; }
"^"             { return BITXOR; }
"|"             { return BITOR; }
"?"             { return INTERROGATION; }
```

**匹配注释**

```c++
\/\/.*\n					{;}						
[\t\v\r\n\f\a\b]			{;}
```

**匹配常见数据类型**

```c++
[0-9]+\.[0-9]+				{ 
								double dtmp;
								sscanf(yytext, "%lf", &dtmp);
								yylval.dVal = dtmp;
								return REAL; 
							}
[0-9]+						{
								int itmp;
								sscanf(yytext, "%d", &itmp);
								yylval.iVal = itmp; 
								return INTEGER; 
							}
\'.\'         				{ 
								yylval.cVal = yytext[1];
								return CHAR;
							}
\'\\.\'   					{
								yyval.cVal = SecondChar(yytext[2]);
								return CHAR;
							}					
\"(\\.|[^"\\])*\"      		{	
								yylval.sVal = new std::string(yytext, yyleng);
								return STRING;
							}
[a-zA-Z_]([a-zA-Z_0-9])*	{
								yylval.sVal = new std::string(yytext, yyleng);
								return IDENTIFER;
							}								
```

**将特定的转义字符映射为其对应的字符。**

```c++
char SecondChar(char ch){
	switch(ch){
	case 'a': return '\a';
	case 'b': return '\b';
	case 'f': return '\f';
	case 'n': return '\n';
	case 'r': return '\r';
	case 't': return '\t';
	case 'v': return '\v';
	case '\\': return '\\';
	case '\'': return '\'';
	case '\"': return '\"';
	default:
		if ('0'<=ch && ch<='9')
			return (char)(ch-'0');
		else
			return ch;
	}
}
```



## 语法分析

Bison（GNU Bison）是一个用于生成语法分析器（parser）的工具。它是 GNU 工具链中的一部分，用于生成解析输入并执行相应操作的语法分析器。Bison 主要用于生成 LALR（Look-Ahead Left-to-Right）类型的语法分析器，它是一种自下而上（bottom-up）的分析方法。

Bison 的工作原理：

1. 定义语法规范：使用 Bison 的语法规范文件（通常以 `.y` 扩展名），定义输入语言的语法规则。这些规则基于上下文无关文法，描述了语言的语法结构和语义。
2. 生成解析器：使用 Bison 工具对语法规范文件进行处理，生成 C 或 C++ 代码的解析器程序。
3. 编译和构建：将生成的解析器程序与其他必要的代码进行编译和链接，生成最终的可执行程序或库。
4. 运行解析器：将输入传递给生成的解析器程序，它会根据语法规范对输入进行分析，并根据规则执行相应的操作。

bison也由三部分组成

```c++
/* 语法规范部分 */
%{
  // 附加代码和声明
%}
/* Bison 的语法规则 */
%%
/* 语法规则和语义动作 */
%%
/* 附加代码 */
/* 其他辅助函数或附加代码 */
```

1. 包含头文件和声明：代码以 `%{ ... %}` 包围的部分用于包含头文件和声明，其中包括 "AST.h" 和 `<iostream>` 头文件，以及一个名为 `root` 的全局变量声明。

```c
%{
    #include "AST.h"
    #include <iostream>
    BlockNode* root; 
}%
```



2. `%union` 声明：在 Bison 中，可以使用 `%union` 声明来定义一个联合体，用于指定语法规则中的非终结符类型。联合体中的不同成员用于表示不同的非终结符类型，例如 `Node`、`ExpNode`、`StmNode` 等。

```c
%union {
    Node *node;
    ExpNode *exp;
    StmNode *stm;
    IdentifierNode *identifier;
    BlockNode *block;
    VarDecNode *vardec;
    std::string *str;
    std::vector<stm*> *stmlist;
    std::vector<exp*> *explist;
    std::vector<vardec*> *vardeclist;

}
```

3. 定义语法规则和终结符：在 Bison 代码中，使用 `%token` 声明定义了一组终结符（tokens），例如 `BREAK`、`IF`、`RETURN` 等。这些终结符用于构建语法规则。

```c
%token BREAK ELSE IF RETURN WHILE FOR AND OR LE GE EQ NE SEMICOLON LBRACE RBRACE
%token COMMA COLON ASSIGN LPARENT RPARENT LBRACKET RBRACKET
%token DOT BITAND NOT BITNOT PLUS SUB MUL DIV MOD LT GT BITXOR BITOR INTERROGATION
%token<iVal> INTEGER
%token<dVal> REAL
%token<cVal> CHAR
%token<sVal> STRING
```

4. `%type` 声明：使用 `%type` 声明指定了不同非终结符的类型，例如 `<identifier>`、`<exp>`、`<stm>` 等。

```c
%type <identifier> identifier
%type <exp> exp 
%type <stm> stm vardec fundec
%type <explist> call_args
%type <stmlist> stmlist
%type <vardeclist> fun_args
%type <block> program stm block
```

5. 语法规则：在 Bison 代码的 `%%` 部分，定义了一系列语法规则，每个规则由一个非终结符和对应的产生式组成。每个规则后面可以跟随一个或多个语义动作，用于在解析过程中执行相应的操作。语义动作：语法规则中的语义动作使用代码块 `{ ... }` 定义，可以包含 C++ 代码片段。语义动作可以执行与语法结构相关的操作，例如创建相应的 AST 节点、进行计算、生成中间代码等。

```c
program:
stmlist{
    root = $1;
};
stmlist:
stm{$$ = new BlockNode();}
|stmlist stm;

stm:
fundec 
| vardec SEMICOLON
| exp SEMICOLON{$$ = new ExpStmNode(*$1);}
| RETURN SEMICOLON{$$ = new ReturnNULLStmNode();}
| RETURN ex SEMICOLON{$$ = new ReturnStmNode();}
| BREAK SEMICOLON{$$ = new BreakStmNode();}
| IF LPARENT exp RPARENT block {$$ = IfStmNode(*$3,*$5);}
| IF LPARENT exp RPARENT block ELSE block {$$ = new IfElseStmNode(*$3,*$5,*$7);}
| WHILE LPARENT exp RPARENT block {$$ = new WhileStmNode(*$3,*$5);}
| FOR LPARENT exp RPARENT block {$$ = new ForStmNode(*$3,*$5);};
;

block:
LBRACE stmlist RBRACE{$$ = $2;}
| LBRACE RBRACE{$$ = new BlockNode();};

vardec:
identifier identifier{$$ = new VarDecNode(*$1,*$2);}
| identifier identifier ASSIGN exp{$$ = new VarDecNode(*$1,*$2,$4);}
| identifier identifier  LBRACKET  INTEGER  RBRACKET {$$ = new VarDecNode(*$1,*$2,$4);};

fundec:
identifier identifier LPARENT fun_args RPARENTblock{
    $$ = new FunDecNode(*$1, *$2, *$4, *$6);
};

fun_args:
 {$$ = new std::vector<VarDecNode*>();}
| fun_args COMMA vardec{$1 -> push_back($$3);}
| vardec{
    $$ = new std::vector<VarDecNode*>();
    $$ -> push_back($$1);
};

identifier:
IDENTIFER {$$ = new IdentifierNode(*$1);};

INTEGER {
    $$ = new IntNode(*$1);
};
REAL {
    $$ = new DoubleNode(*$1);
};
CHAR {
    $$ = new CharNode(*$1);
};
STRING {
    $$ = new StringNode(*$1);
};

call_args
    {
        $$ = new std::vector<ExpressionNode*>();
    }
    | expression {
        $$ = new std::vector<ExpressionNode*>();
        $$->push_back($1);
    }
    | call_args COMMA expression {
        $1->push_back($3);
    };

exp:
identifier ASSIGN exp{$$ = new AssignNode(*$1,*$3);}
| identifier '(' call_args ')' {$$ = new FunCallNode(*$1,*$3);}
| exp PLUS exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp MINUS exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp MUL exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp DIV exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp AND exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp OR exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp LE exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp GE exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp EQ exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp NE exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp LT exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp GT exp {$$ = new BinOpNode($2,*$1,*$3);}
| identifier  LBRACKET  exp  RBRACKET  {$$ = new ArrayEleNode(*$1,*$3);}
| identifier  LBRACKET  exp  RBRACKET  ASSIGN exp {$$ = new ArrayAssNode(*$1,*$3,*$6);}
| identifier { $$ = $1 ;}
| '*' identifier {$$ = getAddrNode(*$2);}
| '*' identifier '[' exp ']' {$$ = getArrayAddrNode(*$2,*$4);}
| INTEGER | CHAR | REAL | STRING
| LPARENT exp RPARENT{$$ = $2}
```



## 抽象语法树

抽象语法树（Abstract Syntax Tree，AST）是在语法分析阶段生成的一种树状数据结构，用于表示源代码的抽象语法结构。它是源代码的一种抽象表示，剔除了具体语法细节，保留了程序的结构和语义信息。

#### Node类

Node类是抽象语法树每个节点的纯虚类型，包括空的构造、析构函数和纯虚函数 CodeGen

```c++
class Node {
public:
    Node() {}
    virtual ~Node() {}
    virtual string genJson(){};
    virtual llvm::Value *genCode(CodeGenerator & gen);
};
```

#### StmNode类

StmNode类是所有statement语句节点的父类，继承自Node，拥有成员变量block。

```c++
class StmNode : public Node{
public:
    // void forward(CodeGenerator & gen);
    // void backward(CodeGenerator & gen);
    llvm::BasicBlock *block;
};
```

#### ExpNode类

ExpNode类是所有expression语句节点的父类，继承自Node。

```c++
class ExpNode : public Node{
    
};
```

#### Const

常量节点，继承自Node，包括`IntNode`,`CharNode`,`DoubleNode`,`StringNode`

```c++
class IntNode : public Const{
public:
    IntNode(int value) : value(value){}
    virtual C_TYPE getType(){ return C_INTEGER;}
    virtual Const::Value getValue(){
        Const::Value v;
        v.i = value;
        return v; 
    }
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    int value;
};
class CharNode : public Const{
public:
    CharNode(char value) : value(value){}
    virtual C_TYPE getType(){ return C_CHAR;}
    virtual Const::Value getValue(){
        Const::Value v;
        v.c = value;
        return v; 
    }
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    char value;
};

class DoubleNode : public Const{
public:
    DoubleNode(double value) : value(value){}
    virtual C_TYPE getType(){ return C_DOUBLE;}
    virtual Const::Value getValue(){
        Const::Value v;
        v.d = value;
        return v; 
    }
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    double value;
};

class StringNode : public ExpNode{
public:
    StringNode(string *value):value(value){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    string *value;
};
```

#### IdentifierNode

标识符的类，继承自Node，拥有name成员变量。

```c++
class IdentifierNode : public ExpNode{
public:
    Identifier(string *name) : name(name){}
    string getname(){return *name;}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    string *name;
};
```

#### ArrayEleNode

表示数组元素访问的表达式节点，在语法树中的节点。它包含一个数组标识符（`IdentifierNode`）和一个索引表达式（`ExpNode`）作为其成员变量。

```c++
class ArrayEleNode : public ExpNode{
public:
    ArrayEleNode(IdentifierNode* _identifier,ExpNode* _index):identifier(_identifier),index(_index){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
    
    IdentifierNode * identifier;
    ExpNode* index;
};
```



#### ArrayAssNode

表示数组元素赋值的表达式节点，在语法树中的节点。它包含一个数组标识符（`IdentifierNode`）、一个索引表达式（`ExpNode`）和一个右侧表达式（`ExpNode`）作为其成员变量。

```c++
class ArrayAssNode : public ExpNode{
public:
    ArrayAssNode(IdentifierNode* _identifier,ExpNode* _index,ExpNode* _rhs):identifier(_identifier),index(_index),rhs(_rhs){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode * identifier;
    ExpNode* index;
    ExpNode* rhs; 
};
```



#### FunCallNode

表示函数调用的表达式节点，在语法树中的节点。它包含一个函数标识符（`IdentifierNode`）和参数列表（`vector<ExpNode*>`）作为其成员变量。

```c++
class FunCallNode : public ExpNode{
public:
    FunCallNode(IdentifierNode *_identifier, vector<ExpNode*> _args) : identifier(_identifier), args(_args) {}
    FunCallNode(IdentifierNode *_identifier) :  identifier(identifier) {}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode * identifier;
    vector<ExpNode*> args;

};
```



#### BinOpNode

表示二元操作符的表达式节点，在语法树中的节点。它包含一个操作符（`op`，作为整数）、一个左操作数（`l`，`ExpNode` 类型）和一个右操作数（`r`，`ExpNode` 类型）作为其成员变量。

```c++
class BinOpNode : public ExpNode{
public:
    BinOpNode(int _op,ExpNode* _l,ExpNode* _r):op(_op),l(_l),r(_r){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
    int op;
    ExpNode* l;
    ExpNode* r;
};
```



#### getAddrNode

表示获取变量地址的表达式节点，在语法树中的节点。它包含一个变量标识符（`IdentifierNode`）作为其成员变量。

```c++
class getAddrNode : public ExpNode{
public:
    getAddrNode(IdentifierNode *_identifier):identifier(_identifier){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode *identifier;
};
```



#### AssignNode

表示赋值操作的表达式节点，在语法树中的节点。它包含一个变量标识符（`IdentifierNode`）和一个左操作数（`ExpNode` 类型）作为其成员变量。

```c++
class AssignNode : public ExpNode{
public:
    AssignNode(IdentifierNode *_identifier, ExpNode *_index) :lhs(_index), identifier(_identifier) {}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode *identifier;
    ExpNode *lhs;
};
```



#### BlockNode

表示代码块的表达式节点，在语法树中的节点。它包含一个语句列表（`vector<StmNode*>`）作为其成员变量。

```c++
class BlockNode : public ExpNode{
public:
    BlockNode(){}
    BlockNode(vector<StmNode*> _stmlist):stmlist(_stmlist){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    vector<StmNode*> stmlist;
};
```



#### ExpStmNode

表示一个表达式语句，在语法树中的节点。它包含一个表达式（`ExpNode`）作为其成员变量。

```c++
class ExpStmNode : public StmNode{
public:
    ExpStmNode(ExpNode* _exp):exp(_exp){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    ExpNode* exp;
};
```



#### BreakStmNode

表示一个`break`语句，在语法树中的节点。它表示在循环或`switch`语句中使用的跳出语句。

```c++
class BreakStmNode : public StmNode{
public:
    BreakStmNode(){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
};
```



#### IfStmNode 

表示一个`if`语句，在语法树中的节点。它包含一个条件表达式（`ExpNode`）和一个代码块（`BlockNode`）作为其成员变量。

```c++
class IfStmNode : public StmNode{
public:
    IfStmNode(ExpNode* _exp,BlockNode*_block):exp(_exp),block(_block){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    ExpNode *exp;
    BlockNode *block;
};
```



#### IfElseStmNode

表示一个带有`else`分支的`if`语句，在语法树中的节点。它包含一个条件表达式（`ExpNode`）、一个`if`代码块（`BlockNode`）和一个`else`代码块（`BlockNode`）作为其成员变量。

```c++
class IfElseStmNode : public StmNode{
public:
    IfElseStmNode(ExpNode* _exp,BlockNode*_block,BlockNode*block_):exp(_exp),ifblock(_block),elseblock(block_){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    ExpNode *exp;
    BlockNode *ifblock,*elseblock;
};
```



#### WhileStmNode  

表示一个`while`循环语句，在语法树中的节点。它包含一个循环条件表达式（`ExpNode`）和一个代码块（`BlockNode`）作为其成员变量。

```c++
class WhileStmNode : public StmNode{
public:
    WhileStmNode(ExpNode* _exp,BlockNode*_block):exp(_exp),block(_block){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
    ExpNode *exp;
    BlockNode *block;
};
```



#### ForStmNode

表示一个`for`循环语句，在语法树中的节点。它包含一个循环条件表达式（`ExpNode`）和一个代码块（`BlockNode`）作为其成员变量。

```c++
class ForStmNode : public StmNode{
public:
    ForStmNode(ExpNode* _exp,BlockNode*_block):exp(_exp),block(_block){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
    ExpNode *exp;
    BlockNode *block;
};
```



#### ReturnNullStmNode

表示一个不带返回值的`return`语句，在语法树中的节点。

```c++
class ReturnNullStmNode : public StmNode{
public:
    ReturnNullStmNode(){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

};
```



#### ReturnStmNode

表示一个带有返回值的`return`语句，在语法树中的节点。它包含一个返回值表达式（`ExpNode`）作为其成员变量。

```c++
class ReturnStmNode : public StmNode{
public:
    ReturnStmNode(ExpNode* _exp):exp(_exp){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    ExpNode *exp;
};
```



#### VarDecNode 

表示一个变量声明语句，在语法树中的节点。它包含一个类型标识符（`IdentifierNode`）、一个变量标识符（`IdentifierNode`）和可选的初始化表达式（`ExpNode`）作为其成员变量。

```c++
class VarDecNode : public StmNode{
public:
    VarDecNode(IdentifierNode* _type ,IdentifierNode* _identifier ):type(_type),identifier(_identifier){}
    VarDecNode(IdentifierNode* _type ,IdentifierNode* _identifier, int _size ):type(_type),identifier(_identifier),size(_size){}
    VarDecNode(IdentifierNode* _type ,IdentifierNode* _identifier, ExpNode* assign ):type(_type),identifier(_identifier),exp(assign){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode *type;
    IdentifierNode *identifier;
    ExpNode* exp;
    int size;

};
```



#### FunDecNode 

表示一个函数声明语句，在语法树中的节点。它包含一个返回类型标识符（`IdentifierNode`）、一个函数标识符（`IdentifierNode`）、参数列表（`vector<VarDecNode*>`）和一个代码块（`BlockNode`）作为其成员变量。

```c++
class FunDecNode : public StmNode{
public:
    FunDecNode(IdentifierNode *_type, IdentifierNode *_identifier, 
    vector<VarDecNode*> _args, BlockNode *_block) :  type(_type), identifier(_identifier), args(_args), block(_block) {}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode *type;
    IdentifierNode *identifier;
    BlockNode *block;
    vector<VarDecNode*> args;
};
```



## CodeGenerator



储存生成中间代码的变量以及函数。

使用`symbol_Table`来作为符号表存储块内的变量表 local_var 及对应的变量-llvm 类型表 local_var_type。

CodeGenerator 类主要存储了一个符号栈，同时存有 LLVM::module 以及所定义的输入输出函数；

```c++
vector<symbolTable *> symbolTable_stack; 
llvm::Module *myModule; 
llvm::Function *printf,*scanf, *gets;
llvm::Function* currentFunc;
llvm::BasicBlock* returnBB;
llvm::Value* returnVal;
bool isArgs;
bool hasReturn;
```

同时定义了查找变量的函数`findVariable`

以及对`scanf`,`printf`,`gets`操作的函数

```c++
llvm::Function* getPrintf(); 
llvm::Function* getScanf(); 
llvm::Function* getGets(); 
llvm:: Value* emitScanf(CodeGenerator &emitContext,vector<ExpNode*> args);
llvm:: Value* emitPrintf(CodeGenerator &emitContext,vector<ExpNode*> args);
llvm:: Value* emitGets(CodeGenerator &emitContext,vector<ExpNode*> args);
vector<llvm::Value *> *getPrintfArgs(CodeGenerator &emitContext,vector<ExpNode*>args);
vector<llvm::Value *> *getScanfArgs(CodeGenerator &emitContext,vector<ExpNode*>args);
vector<llvm::Value *> *getGetsArgs(CodeGenerator &emitContext,vector<ExpNode*>args);
```



## ast.cpp分析



此文件实现ast.h中的**genCode**方法,将每个节点转换为llvmIR中间代码



**const**部分：

对于**int**,**double**,**char**,**string**类型的节点，传入全局上下文globalContext，返回对应llvm::constant种类.

```c
llvm::Value *IntNode::genCode(CodeGenerator & gen){
    cout << "IntNode : " << value <<endl;
    return llvm::ConstantInt::get(gen.context, llvm::APInt(32, intValue, true));
}
```

对于**IdentifierNode**，首先在符号表中搜索是否已有该变量，若该变量未声明过则报错**"undeclared variable"**，最后通过**llvm::LoadInst**函数进行加载。

```c
llvm::Value *IdentifierNode::genCode(CodeGenerator & gen){
    llvm::Value* variable = gen.findVariable(name);
    if(variable == nullptr){
        std::cerr << "undeclared variable " << name << endl;
        return nullptr;
    }
    llvm::Type* tp = variable->getType()->getPointerElementType();
    llvm::Value* res = nullptr;
    // 如果传入的是一个数组的 ID
    if(tp->isArrayTy()) {
        vector<llvm::Value*> indexList;
        indexList.push_back(Builder.getInt32(0));
        indexList.push_back(Builder.getInt32(0));
        res = Builder.CreateInBoundsGEP(variable, indexList, "arrayPtr");
    }
    else {
        res = new llvm::LoadInst(tp, variable, "LoadInst", false, Builder.GetInsertBlock());
    }
    return res;
}
```

对于**ArrayEleNode**，首先找到其数组名对应的**llvm::value**，再得到其下标**index**值，再调用IRbuilder里的**createInBoundsGEP**函数，得到数组中对应元素的值，这里的数组标识符可能是数组类型，也可能是指针类型，对于两种类型要进行不同的处理

```c
llvm::Value *ArrayEleNode::genCode(CodeGenerator & gen){
    llvm::Value* arrayValue = gen.findVariable(identifier.name);
    if(arrayValue == nullptr){
        cerr << "undeclared array " << identifier.name << endl;
		return nullptr;
    }
    llvm::Value* indexValue = index.genCode(gen);
    vector<llvm::Value*> indexList;
    // 如果是一个指针
    if(arrayValue->getType()->getPointerElementType()->isPointerTy()) {
        arrayValue = Builder.CreateLoad(arrayValue->getType()->getPointerElementType(), arrayValue);
        indexList.push_back(indexValue);    
    }
    // 如果是一个数组 
    else {
        indexList.push_back(Builder.getInt32(0));
        indexList.push_back(indexValue);    
    }
    llvm::Value* elePtr =  
    Builder.CreateInBoundsGEP(arrayValue, llvm::ArrayRef<llvm::Value*>(indexList), 	"tmparray");
    return Builder.CreateLoad(elePtr->getType()->getPointerElementType(), elePtr, "tmpvar");
    
}
```

对于**FunCallNode**，函数调用时，首先判断是否为printf/scanf/gets函数，若是则直接进入相关函数，否则查找有无该函数名的函数，若无则报错**“no such function"**，否则先对调用中传入的每个参数调用genCode函数，再调用callinst函数实现一条call指令完成函数的调用；

```c
llvm::Value *FunCallNode::genCode(CodeGenerator & gen){
   	//判断是否为printf/scanf/gets函数
    if(identifier.name == "printf"){ 
        return emitPrintf(gen, args);
    } else if(identifier.name == "scanf"){ 
        return emitScanf(gen, args);
    } else if(identifier.name == "gets") { 
        return emitGets(gen, args);
    }
    //在module中查找以identifier命名的函数
    llvm::Function *func = gen.Module->getFunction(identifier.name.c_str());
    if (func == NULL) {
		std::cerr << "no such function " << identifier.name << endl;
	}
    //对每个ExpressionNode进行genCode 并将结果存入tmp中
    vector<llvm::Value*> tmp;
    vector<ExpressionNode*>::iterator i;
    for(auto i : args){  
        tmp.push_back((*i).genCode(gen));
    }
    //函数调用
    llvm::CallInst *call = llvm::CallInst::Create(func,llvm::makeArrayRef(tmp),"",Builder.GetInsertBlock());
    cout << "Creating method call: " << identifier.name << endl;
	return call;

}
```

对于**BinOpNode**,分别先对运算符左右两边进行genCode，之后判断操作符的种类，分别返回其对应的llvm::instruction类中对应的二元运算符，再返回Create函数；支持的运算符分别有“+”、“-”、“*”、“/”、“and”、“or”、“=”等，因为parsing中传入的为符号对应的数字，所以为op与数字的比较。这里在进行运算前需要先对两边类型进行判断，按照c语言规则进行类型提示，无法转换的则需要报错.

```c
llvm::Value *BinOpNode::genCode(CodeGenerator & gen){
    cout << "BinaryOpNode : " << op << endl;
    llvm::Value* left = lhs.genCode(gen);
    llvm::Value* right = rhs.genCode(gen);
    llvm::Instruction::BinaryOps bi_op;
	//“+”、“-”、“*”、“/”
    if(op == 0 || op == 1 || op == 2 || op == 3){
        if(op == 0){bi_op = left->getType()->isFloatTy() ? 
            				llvm::Instruction::FAdd : llvm::Instruction::Add;}
        else if(op == 1){bi_op = left->getType()->isFloatTy() ? 
            					llvm::Instruction::FSub : llvm::Instruction::Sub;}
        else if(op == 2){bi_op = left->getType()->isFloatTy() ? 
            					llvm::Instruction::FMul : llvm::Instruction::Mul;}
        else if(op == 3){bi_op = left->getType()->isFloatTy() ? 
            					llvm::Instruction::FDiv : llvm::Instruction::SDiv;}
        return llvm::BinaryOperator::Create(bi_op,left,right,"", Builder.GetInsertBlock());
    }
    //AND
    else if(op == 4){
        return Builder.CreateAnd(left, right, "tmpAnd");
    }
    //OR
    else if (op == 5) {
        return Builder.CreateOr(left, right, "tmpOR");
    }
 	//EQ等
    else if (op == 6) {
        return (left->getType() == llvm::Type::getFloatTy(myContext)) ? Builder.CreateFCmpOEQ(left, right, "fcmptmp") : Builder.CreateICmpEQ(left, right, "icmptmp");
    }
    else if (op == 7) {
        return (left->getType() == llvm::Type::getFloatTy(myContext)) ? Builder.CreateFCmpOGE(left, right, "fcmptmp") : Builder.CreateICmpSGE(left, right, "icmptmp");
    }
    else if (op == 8) {
        return (left->getType() == llvm::Type::getFloatTy(myContext)) ? Builder.CreateFCmpOLE(left, right, "fcmptmp") : Builder.CreateICmpSLE(left, right, "icmptmp");
    }
    else if (op == 9) {
        return (left->getType() == llvm::Type::getFloatTy(myContext)) ? Builder.CreateFCmpOGT(left, right, "fcmptmp") : Builder.CreateICmpSGT(left, right, "icmptmp");
    }
    else if (op == 10) {
        return (left->getType() == llvm::Type::getFloatTy(myContext)) ? Builder.CreateFCmpOLT(left, right, "fcmptmp") : Builder.CreateICmpSLT(left, right, "icmptmp");
    }
    else if (op == 11) {
        return (left->getType() == llvm::Type::getFloatTy(myContext)) ? Builder.CreateFCmpONE(left, right, "fcmptmp") : Builder.CreateICmpNE(left, right, "icmptmp");
    }
    return NULL;

```

对于**AssignNode**,首先查找左值是否已被定义，接下来将右值gencode，最后利用IRbuilder定位到当前所在block，调用**llvm::StoreInst**函数创造一条store指令；

```c
llvm::Value *AssignNode::genCode(CodeGenerator & gen){
    cout << "AssignmentNode,lhs: " << lhs.name << endl;
    
    // 在符号表和全局变量中查找
    llvm::Value* result = gen.findVariable(lhs.name);
    if(result == nullptr){
        cerr << "undeclared variable " << lhs.name << endl;
		return nullptr;
    }

    llvm::Value* right = rhs.genCode(gen);
    // 定位 block
    auto CurrentBlock = Builder.GetInsertBlock();
    //cast
    if (right->getType() != result->getType()->getPointerElementType())
        right = typeCast(right, result->getType()->getPointerElementType());
	//store
    return new llvm::StoreInst(right, result, false, CurrentBlock);
}
```

对于**IfElseStmNode**，会分别为condition条件、if、以及else部分生成block，再调用SetInsertPoint函数在其对应位置插入语句，调用CreatBr函数创建分支跳转，实现若condition条件符合则进入if-block，否则进入else-block；

```c
llvm::Value *IfElseStmNode::genCode(CodeGenerator & gen) {
    llvm::Function* func = gen.currentFunc;
    llvm::BasicBlock*  condition_block = llvm::BasicBlock::Create(globalContext, "C_block", func);
    llvm::BasicBlock*  if_block = llvm::BasicBlock::Create(globalContext, "I_block", func);
    llvm::BasicBlock*  else_block = llvm::BasicBlock::Create(globalContext, "EL_block", func);
    llvm::BasicBlock*  end_block = llvm::BasicBlock::Create(globalContext, "E_block", func);
    llvm::Value* condition_value = exp->genCode(gen);
    Builder.CreateCondBr(condition_value, if_block, else_block);

    Builder.SetInsertPoint(if_block);
    gen.symbolTable_stack.push_back({});
    ifblock->genCode(gen);
    gen.symbolTable_stack.pop_back();
    if (!Builder.GetInsertBlock()->getTerminator()){
        Builder.CreateBr(end_block);
    }

    Builder.SetInsertPoint(else_block);
    gen.symbolTable_stack.push_back({});
    elseblock->genCode(gen);
    gen.symbolTable_stack.pop_back();
    if (!Builder.GetInsertBlock()->getTerminator()){
        Builder.CreateBr(end_block);
    }
    
    Builder.SetInsertPoint(end_block);
    return nullptr;
}
```

对于**WhileStmNode**,该节点与ifelse基本相同，均为判断相应条件后进入相应block。

```c
llvm::Value *WhileStmNode::genCode(CodeGenerator & gen){
    cout << "Generating code for while "<<endl;

    llvm::Function *TheFunction = gen.currentFunc;

    llvm::BasicBlock *condBB = llvm::BasicBlock::Create(myContext, "cond", TheFunction);
    llvm::BasicBlock *loopBB = llvm::BasicBlock::Create(myContext, "loop", TheFunction);
    llvm::BasicBlock *afterBB = llvm::BasicBlock::Create(myContext, "afterLoop", TheFunction);

    GlobalAfterBB.push(afterBB);

    Builder.CreateBr(condBB);
    Builder.SetInsertPoint(condBB);

    llvm::Value *condValue = expression.genCode(gen);
    condValue = Builder.CreateICmpNE(condValue, llvm::ConstantInt::get(llvm::Type::getInt1Ty(myContext), 0, true), "whileCond");
    auto branch = Builder.CreateCondBr(condValue, loopBB, afterBB);
    condBB = Builder.GetInsertBlock();

    Builder.SetInsertPoint(loopBB);

    // 将 while 的域放入栈顶
    gen.pushBlock();
    block.genCode(gen);
    if(gen.hasReturn)
        gen.hasReturn = false;
    else
        Builder.CreateBr(condBB);

    // while 结束, 将 while 的域弹出栈顶
    gen.popBlock();
    Builder.SetInsertPoint(afterBB);

    GlobalAfterBB.pop();
    return branch;
}

```

对于**VarDecNode**，要先判断是普通变量还是数组的定义，确定类型后分别判断其是全局变量还是局部变量，然后对应分别新建Globalvariable和allocinst指令，创建新的变量；创建变量前会检查是否为重复定义，此处还会判断是否在定义时为其赋了初值，若是的话也会同时再调用assignmentNode为其赋值；

```c
llvm::Value* VarDecNode::genCode(CodeGenerator & gen) {  
    if(size == 0){ //非数组
        llvm::Type* llvmType = getLLvmType(type.name);
        // 全局变量
        if(globalContext.currentFunc == nullptr) {
            //查找变量防止重新定义
            llvm::GlobalVariable *tmp = globalContext.myModule->getNamedGlobal(identifier.name);
            if(tmp != nullptr){
                throw logic_error("Redefined Global Variable: " + identifier.name);
            }
            //新建全局变量
            llvm::GlobalVariable* New_globalVar = new llvm::GlobalVariable(*(globalContext.myModule), llvmType, false, llvm::GlobalValue::PrivateLinkage, 0, identifier.name);
            //类型 ， 非数组单个变量偏移为0
            New_globalVar->setInitializer(llvm::ConstantInt::get(llvmType, 0));
            return nullptr;
        } else {//函数内部变量
            //cout << "Creating local variable declaration " << type.name << " " << identifier.name<< endl;
            //指向当前函数块
            auto *block = Builder.GetInsertBlock();
            // 当前域中已经有该变量, 重复定义        
            if(globalContext.getTop().count(identifier.name) != 0) {
                throw logic_error("Redefined Local Variable: " + identifier.name);
            }
            //空间声明
            llvm::AllocaInst *alloc = new llvm::AllocaInst(llvmType,block->getParent()->getParent()->getDataLayout().getAllocaAddrSpace(),(identifier.name.c_str()), block);
            // 将新定义的变量类型和地址存入符号表中
            globalContext.getTopType()[identifier.name] = llvmType;
            globalContext.getTop()[identifier.name] = alloc;
            //是否赋值
            if (exp != NULL) {
                AssignNode assign(identifier, *exp);
                assign.genCode(globalContext);
            }
            return alloc;
        }
    }
```

对于**FunDecNode**,调用FunctionType得到函数类型，再调用llvm::Function创造函数；之后创建一个基本块并压入栈，这样可以区分函数内与外界作用域；之后对函数后的block进行genCode，最后函数结束后从栈中pop出来；

```c
llvm::Value* FunDecNode::genCode(CodeGenerator & gen){
	vector<llvm::type> args_types;
    for(auto it : args){
        if(it->size == 0)//除数组外其它size赋值为0
            args_types.push_back(getLLvmType(it->type.name));
        else//array 
        {
            args_types.push_back(getPtrLLvmType(it->type.name));
        }
    }
    //FunctionType::get调用用于为给定的函数原型创建对应的FunctionType对象。
    //随后，FunctionType::get方法以args_types为参数类型、以单个type为返回值类型，
    //创建出一个参数个数不可变（最后一个参数false就是这个意思）的函数类型。
    llvm::FunctionType *Ftype = llvm::FunctionType::get(getLLvmType(type.name), makeArrayRef(args_types), false);
    // “ExternalLinkage”表示该函数可能定义于当前模块之外，且/或可以被当前模块之外的函数调用;name函数名;符号表注册
    llvm::Function *F = Function::Create(Ftype, llvm::Function::ExternalLinkage, identifier->name.c_str(), gen.module);
    //新建了一个名为“entry”的基本块对象，稍后该对象将被插入F
    llvm::BasicBlock *basicblock = llvm::BasicBlock::Create(globalContext, "entry", F);
    //告诉Builder，后续的新指令应该插至刚刚新建的基本块的末尾处
    Builder.SetInsertPoint(basicblock);

    gen.currentFunc = F;
    gen.returnBB = llvm::BasicBlock::Create(globalContext, "return", F);
    
    //函数有返回值s
    if(type.name.compare("void") != 0) {
        //返回值空间分配
        globalContext.returnVal = new llvm::AllocaInst(getLLvmType(type.name), basicblock->getParent()->getParent()->getDataLayout().getAllocaAddrSpace(), "", basicblock);
    }
    //压入新符号表
	globalContext.pushBlock();
	llvm::Function::arg_iterator args_Values = F->arg_begin();
    llvm::Value* Tmp_Value;
    //遍历参数
    globalContext.isArgs = true;// (*it).genCode(globalContext);用
    for(auto it : args){
        (*it).genCode(globalContext);
        Tmp_Value = args_Values;
        args_Values++;
        Tmp_Value->setName((it)->identifier.name.c_str());
        //StoreInst (Value *Val, Value *Ptr, bool isVolatile, BasicBlock *InsertAtEnd)
        //          要插的值    ，目标存储指针，是否易变    ，插在哪块后面。
        llvm::StoreInst *inst = new llvm::StoreInst(Tmp_Value, globalContext.getTop()[(it)->identifier.name], false, basicblock);
	}
    globalContext.isArgs = false;
	//函数后函数块处理
	block.genCode(globalContext);
    //重置hasreturn
    globalContext.hasReturn = false;
    //return后操作
    Builder.SetInsertPoint(globalContext.returnBB);
    if(type.name.compare("void") == 0) {
        Builder.CreateRetVoid();
    } else {
        llvm::Value* ret = Builder.CreateLoad(getLLvmType(type.name), globalContext.returnVal, "");
        Builder.CreateRet(ret);
    }

	globalContext.popBlock();
    globalContext.currentFunc = nullptr;
	return F;
}
```

# 测试部分

代码尚存在一些问题。
