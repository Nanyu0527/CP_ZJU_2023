# 编译原理实验报告

##### 曹小川  张骥轩  朱子秋



## 前言



### 运行环境

编程语言：C++

IDE : Vscode



### 依赖项

1. Flex & Bison

   使用flex和bison生成词法分析器和语法分析器。

2. LLVM-14

   使用LLVM来完成语义分析、中间代码生成、编译器优化、目标代码生成。



## 词法分析

Flex（Fast Lexical Analyzer Generator）是一个用于生成词法分析器的工具。它是GNU项目中的一部分。

Flex接受一组正则表达式和对应的动作规则作为输入，然后生成一个C/C++源代码文件，该文件实现了一个高效的词法分析器。词法分析器用于将输入文本流分解为一系列的标记（token），这些标记可以在编译器、解释器和其他语言处理工具中用于进一步的语法分析。

Flex的工作流程如下：

1. 用户定义一系列的正则表达式和与之对应的动作规则。这些规则描述了词法分析器如何识别和处理不同的标记。
2. Flex读取这些规则，并根据规则生成一个有限状态自动机（Finite State Machine，FSM）。
3. Flex根据有限状态自动机生成C/C++源代码文件，其中包含了识别和处理输入文本流的逻辑。
4. 用户可以将生成的源代码文件编译为可执行文件，从而得到一个高效的词法分析器。



flex的输入文件由三段构成：

```c++
definition
%%
rules
%%
user's code
```

1. 定义部分（Definition）： 定义部分用于声明全局变量、包含头文件和宏定义等。这一部分通常位于代码的开头，并且以`%{`和`%}`包围起来。在定义部分中，你可以定义和声明词法分析器所需的全局变量、常量、宏以及需要引入的头文件。
2. 规则部分（Rules）： 规则部分是Flex中最重要的部分，它包含了一系列的正则表达式和与之对应的动作规则。每个规则由一个正则表达式和一个与之关联的动作组成。当输入流匹配某个规则时，对应的动作将被执行。规则部分使用特殊的语法来定义正则表达式和动作规则。通常，规则部分位于`%%`标记之间。
3. 用户代码部分（User's Code）： 用户代码部分用于编写自定义的C/C++代码，通常用于实现词法分析器生成的动作逻辑之外的其他功能。在这部分中，你可以编写与词法分析器相关的辅助函数、处理分析器返回结果的逻辑、与其他模块进行交互等。用户代码部分位于`%%`标记之后，即规则部分的后面。

#### 定义部分

定义部分包括了必须插到第一部分 %{ 和 %} 之间的C代码，包括头文件定义和逃逸字符返回函数

```c++
%{
#include<stdio.h>
#include <string>
#include <iostream>
char SecondChar(char ch);
%}
```



#### 规则部分

**直接匹配字符和关键字**

```c++
/*keywords*/
"break"         { return BREAK;    }
"else"          { return ELSE;     }
"if"            { return IF;       }
"return"        { return RETURN;   }
"while"         { return WHILE;    }
"for"           { return FOR;      }
/*operations*/
"&&"            { return AND; }
"||"            { return OR; }
"<="            { return LE; }
">="            { return GE; }
"=="            { return EQ; }
"!="            { return NE; }
";"             { return SEMICOLON; }
"{"             { return LBRACE; }
"}"             { return RBRACE; }
","             { return COMMA; }
":"             { return COLON; }
"="             { return ASSIGN; }
"("             { return LPARENT; }
")"             { return RPARENT; }
"["             { return LBRACKET; }
"]"             { return RBRACKET; }
"."             { return DOT; }
"&"             { return BITAND; }
"!"             { return NOT; }
"~"             { return BITNOT; }
"-"             { return SUB; }
"+"             { return PLUS; }
"*"             { return MUL; }
"/"             { return DIV; }
"%"             { return MOD; }
"<"             { return LT; }
">"             { return GT; }
"^"             { return BITXOR; }
"|"             { return BITOR; }
"?"             { return INTERROGATION; }
```

**匹配注释**

```c++
\/\/.*\n					{;}						
[\t\v\r\n\f\a\b]			{;}
```

**匹配常见数据类型**

```c++
[0-9]+\.[0-9]+				{ 
								double dtmp;
								sscanf(yytext, "%lf", &dtmp);
								yylval.dVal = dtmp;
								return REAL; 
							}
[0-9]+						{
								int itmp;
								sscanf(yytext, "%d", &itmp);
								yylval.iVal = itmp; 
								return INTEGER; 
							}
\'.\'         				{ 
								yylval.cVal = yytext[1];
								return CHAR;
							}
\'\\.\'   					{
								yyval.cVal = SecondChar(yytext[2]);
								return CHAR;
							}					
\"(\\.|[^"\\])*\"      		{	
								yylval.sVal = new std::string(yytext, yyleng);
								return STRING;
							}
[a-zA-Z_]([a-zA-Z_0-9])*	{
								yylval.sVal = new std::string(yytext, yyleng);
								return IDENTIFER;
							}								
```

**将特定的转义字符映射为其对应的字符。**

```c++
char SecondChar(char ch){
	switch(ch){
	case 'a': return '\a';
	case 'b': return '\b';
	case 'f': return '\f';
	case 'n': return '\n';
	case 'r': return '\r';
	case 't': return '\t';
	case 'v': return '\v';
	case '\\': return '\\';
	case '\'': return '\'';
	case '\"': return '\"';
	default:
		if ('0'<=ch && ch<='9')
			return (char)(ch-'0');
		else
			return ch;
	}
}
```



## 语法分析

Bison（GNU Bison）是一个用于生成语法分析器（parser）的工具。它是 GNU 工具链中的一部分，用于生成解析输入并执行相应操作的语法分析器。Bison 主要用于生成 LALR（Look-Ahead Left-to-Right）类型的语法分析器，它是一种自下而上（bottom-up）的分析方法。

Bison 的工作原理：

1. 定义语法规范：使用 Bison 的语法规范文件（通常以 `.y` 扩展名），定义输入语言的语法规则。这些规则基于上下文无关文法，描述了语言的语法结构和语义。
2. 生成解析器：使用 Bison 工具对语法规范文件进行处理，生成 C 或 C++ 代码的解析器程序。
3. 编译和构建：将生成的解析器程序与其他必要的代码进行编译和链接，生成最终的可执行程序或库。
4. 运行解析器：将输入传递给生成的解析器程序，它会根据语法规范对输入进行分析，并根据规则执行相应的操作。

bison也由三部分组成

```c++
/* 语法规范部分 */
%{
  // 附加代码和声明
%}
/* Bison 的语法规则 */
%%
/* 语法规则和语义动作 */
%%
/* 附加代码 */
/* 其他辅助函数或附加代码 */
```

1. 包含头文件和声明：代码以 `%{ ... %}` 包围的部分用于包含头文件和声明，其中包括 "AST.h" 和 `<iostream>` 头文件，以及一个名为 `root` 的全局变量声明。

```c
%{
    #include "AST.h"
    #include <iostream>
    BlockNode* root; 
}%
```



2. `%union` 声明：在 Bison 中，可以使用 `%union` 声明来定义一个联合体，用于指定语法规则中的非终结符类型。联合体中的不同成员用于表示不同的非终结符类型，例如 `Node`、`ExpNode`、`StmNode` 等。

```c
%union {
    Node *node;
    ExpNode *exp;
    StmNode *stm;
    IdentifierNode *identifier;
    BlockNode *block;
    VarDecNode *vardec;
    std::string *str;
    std::vector<stm*> *stmlist;
    std::vector<exp*> *explist;
    std::vector<vardec*> *vardeclist;

}
```

3. 定义语法规则和终结符：在 Bison 代码中，使用 `%token` 声明定义了一组终结符（tokens），例如 `BREAK`、`IF`、`RETURN` 等。这些终结符用于构建语法规则。

```c
%token BREAK ELSE IF RETURN WHILE FOR AND OR LE GE EQ NE SEMICOLON LBRACE RBRACE
%token COMMA COLON ASSIGN LPARENT RPARENT LBRACKET RBRACKET
%token DOT BITAND NOT BITNOT PLUS SUB MUL DIV MOD LT GT BITXOR BITOR INTERROGATION
%token<iVal> INTEGER
%token<dVal> REAL
%token<cVal> CHAR
%token<sVal> STRING
```

4. `%type` 声明：使用 `%type` 声明指定了不同非终结符的类型，例如 `<identifier>`、`<exp>`、`<stm>` 等。

```c
%type <identifier> identifier
%type <exp> exp 
%type <stm> stm vardec fundec
%type <explist> call_args
%type <stmlist> stmlist
%type <vardeclist> fun_args
%type <block> program stm block
```

5. 语法规则：在 Bison 代码的 `%%` 部分，定义了一系列语法规则，每个规则由一个非终结符和对应的产生式组成。每个规则后面可以跟随一个或多个语义动作，用于在解析过程中执行相应的操作。语义动作：语法规则中的语义动作使用代码块 `{ ... }` 定义，可以包含 C++ 代码片段。语义动作可以执行与语法结构相关的操作，例如创建相应的 AST 节点、进行计算、生成中间代码等。

```c
program:
stmlist{
    root = $1;
};
stmlist:
stm{$$ = new BlockNode();}
|stmlist stm;

stm:
fundec 
| vardec SEMICOLON
| exp SEMICOLON{$$ = new ExpStmNode(*$1);}
| RETURN SEMICOLON{$$ = new ReturnNULLStmNode();}
| RETURN ex SEMICOLON{$$ = new ReturnStmNode();}
| BREAK SEMICOLON{$$ = new BreakStmNode();}
| IF LPARENT exp RPARENT block {$$ = IfStmNode(*$3,*$5);}
| IF LPARENT exp RPARENT block ELSE block {$$ = new IfElseStmNode(*$3,*$5,*$7);}
| WHILE LPARENT exp RPARENT block {$$ = new WhileStmNode(*$3,*$5);}
| FOR LPARENT exp RPARENT block {$$ = new ForStmNode(*$3,*$5);};
;

block:
LBRACE stmlist RBRACE{$$ = $2;}
| LBRACE RBRACE{$$ = new BlockNode();};

vardec:
identifier identifier{$$ = new VarDecNode(*$1,*$2);}
| identifier identifier ASSIGN exp{$$ = new VarDecNode(*$1,*$2,$4);}
| identifier identifier  LBRACKET  INTEGER  RBRACKET {$$ = new VarDecNode(*$1,*$2,$4);};

fundec:
identifier identifier LPARENT fun_args RPARENTblock{
    $$ = new FunDecNode(*$1, *$2, *$4, *$6);
};

fun_args:
 {$$ = new std::vector<VarDecNode*>();}
| fun_args COMMA vardec{$1 -> push_back($$3);}
| vardec{
    $$ = new std::vector<VarDecNode*>();
    $$ -> push_back($$1);
};

identifier:
IDENTIFER {$$ = new IdentifierNode(*$1);};

INTEGER {
    $$ = new IntNode(*$1);
};
REAL {
    $$ = new DoubleNode(*$1);
};
CHAR {
    $$ = new CharNode(*$1);
};
STRING {
    $$ = new StringNode(*$1);
};

call_args
    {
        $$ = new std::vector<ExpressionNode*>();
    }
    | expression {
        $$ = new std::vector<ExpressionNode*>();
        $$->push_back($1);
    }
    | call_args COMMA expression {
        $1->push_back($3);
    };

exp:
identifier ASSIGN exp{$$ = new AssignNode(*$1,*$3);}
| identifier '(' call_args ')' {$$ = new FunCallNode(*$1,*$3);}
| exp PLUS exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp MINUS exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp MUL exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp DIV exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp AND exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp OR exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp LE exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp GE exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp EQ exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp NE exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp LT exp {$$ = new BinOpNode($2,*$1,*$3);}
| exp GT exp {$$ = new BinOpNode($2,*$1,*$3);}
| identifier  LBRACKET  exp  RBRACKET  {$$ = new ArrayEleNode(*$1,*$3);}
| identifier  LBRACKET  exp  RBRACKET  ASSIGN exp {$$ = new ArrayAssNode(*$1,*$3,*$6);}
| identifier { $$ = $1 ;}
| '*' identifier {$$ = getAddrNode(*$2);}
| '*' identifier '[' exp ']' {$$ = getArrayAddrNode(*$2,*$4);}
| INTEGER | CHAR | REAL | STRING
| LPARENT exp RPARENT{$$ = $2}
```



## 抽象语法树

抽象语法树（Abstract Syntax Tree，AST）是在语法分析阶段生成的一种树状数据结构，用于表示源代码的抽象语法结构。它是源代码的一种抽象表示，剔除了具体语法细节，保留了程序的结构和语义信息。

#### Node类

Node类是抽象语法树每个节点的纯虚类型，包括空的构造、析构函数和纯虚函数 CodeGen

```c++
class Node {
public:
    Node() {}
    virtual ~Node() {}
    virtual string genJson(){};
    virtual llvm::Value *genCode(CodeGenerator & gen);
};
```

#### StmNode类

StmNode类是所有statement语句节点的父类，继承自Node，拥有成员变量block。

```c++
class StmNode : public Node{
public:
    // void forward(CodeGenerator & gen);
    // void backward(CodeGenerator & gen);
    llvm::BasicBlock *block;
};
```

#### ExpNode类

ExpNode类是所有expression语句节点的父类，继承自Node。

```c++
class ExpNode : public Node{
    
};
```

#### Const

常量节点，继承自Node，包括`IntNode`,`CharNode`,`DoubleNode`,`StringNode`

```c++
class IntNode : public Const{
public:
    IntNode(int value) : value(value){}
    virtual C_TYPE getType(){ return C_INTEGER;}
    virtual Const::Value getValue(){
        Const::Value v;
        v.i = value;
        return v; 
    }
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    int value;
};
class CharNode : public Const{
public:
    CharNode(char value) : value(value){}
    virtual C_TYPE getType(){ return C_CHAR;}
    virtual Const::Value getValue(){
        Const::Value v;
        v.c = value;
        return v; 
    }
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    char value;
};

class DoubleNode : public Const{
public:
    DoubleNode(double value) : value(value){}
    virtual C_TYPE getType(){ return C_DOUBLE;}
    virtual Const::Value getValue(){
        Const::Value v;
        v.d = value;
        return v; 
    }
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    double value;
};

class StringNode : public ExpNode{
public:
    StringNode(string *value):value(value){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    string *value;
};
```

#### IdentifierNode

标识符的类，继承自Node，拥有name成员变量。

```c++
class IdentifierNode : public ExpNode{
public:
    Identifier(string *name) : name(name){}
    string getname(){return *name;}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    string *name;
};
```

#### ArrayEleNode

表示数组元素访问的表达式节点，在语法树中的节点。它包含一个数组标识符（`IdentifierNode`）和一个索引表达式（`ExpNode`）作为其成员变量。

```c++
class ArrayEleNode : public ExpNode{
public:
    ArrayEleNode(IdentifierNode* _identifier,ExpNode* _index):identifier(_identifier),index(_index){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
    
    IdentifierNode * identifier;
    ExpNode* index;
};
```



#### ArrayAssNode

表示数组元素赋值的表达式节点，在语法树中的节点。它包含一个数组标识符（`IdentifierNode`）、一个索引表达式（`ExpNode`）和一个右侧表达式（`ExpNode`）作为其成员变量。

```c++
class ArrayAssNode : public ExpNode{
public:
    ArrayAssNode(IdentifierNode* _identifier,ExpNode* _index,ExpNode* _rhs):identifier(_identifier),index(_index),rhs(_rhs){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode * identifier;
    ExpNode* index;
    ExpNode* rhs; 
};
```



#### FunCallNode

表示函数调用的表达式节点，在语法树中的节点。它包含一个函数标识符（`IdentifierNode`）和参数列表（`vector<ExpNode*>`）作为其成员变量。

```c++
class FunCallNode : public ExpNode{
public:
    FunCallNode(IdentifierNode *_identifier, vector<ExpNode*> _args) : identifier(_identifier), args(_args) {}
    FunCallNode(IdentifierNode *_identifier) :  identifier(identifier) {}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode * identifier;
    vector<ExpNode*> args;

};
```



#### BinOpNode

表示二元操作符的表达式节点，在语法树中的节点。它包含一个操作符（`op`，作为整数）、一个左操作数（`l`，`ExpNode` 类型）和一个右操作数（`r`，`ExpNode` 类型）作为其成员变量。

```c++
class BinOpNode : public ExpNode{
public:
    BinOpNode(int _op,ExpNode* _l,ExpNode* _r):op(_op),l(_l),r(_r){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
    int op;
    ExpNode* l;
    ExpNode* r;
};
```



#### getAddrNode

表示获取变量地址的表达式节点，在语法树中的节点。它包含一个变量标识符（`IdentifierNode`）作为其成员变量。

```c++
class getAddrNode : public ExpNode{
public:
    getAddrNode(IdentifierNode *_identifier):identifier(_identifier){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode *identifier;
};
```



#### AssignNode

表示赋值操作的表达式节点，在语法树中的节点。它包含一个变量标识符（`IdentifierNode`）和一个左操作数（`ExpNode` 类型）作为其成员变量。

```c++
class AssignNode : public ExpNode{
public:
    AssignNode(IdentifierNode *_identifier, ExpNode *_index) :lhs(_index), identifier(_identifier) {}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode *identifier;
    ExpNode *lhs;
};
```



#### BlockNode

表示代码块的表达式节点，在语法树中的节点。它包含一个语句列表（`vector<StmNode*>`）作为其成员变量。

```c++
class BlockNode : public ExpNode{
public:
    BlockNode(){}
    BlockNode(vector<StmNode*> _stmlist):stmlist(_stmlist){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    vector<StmNode*> stmlist;
};
```



#### ExpStmNode

表示一个表达式语句，在语法树中的节点。它包含一个表达式（`ExpNode`）作为其成员变量。

```c++
class ExpStmNode : public StmNode{
public:
    ExpStmNode(ExpNode* _exp):exp(_exp){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    ExpNode* exp;
};
```



#### BreakStmNode

表示一个`break`语句，在语法树中的节点。它表示在循环或`switch`语句中使用的跳出语句。

```c++
class BreakStmNode : public StmNode{
public:
    BreakStmNode(){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
};
```



#### IfStmNode 

表示一个`if`语句，在语法树中的节点。它包含一个条件表达式（`ExpNode`）和一个代码块（`BlockNode`）作为其成员变量。

```c++
class IfStmNode : public StmNode{
public:
    IfStmNode(ExpNode* _exp,BlockNode*_block):exp(_exp),block(_block){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    ExpNode *exp;
    BlockNode *block;
};
```



#### IfElseStmNode

表示一个带有`else`分支的`if`语句，在语法树中的节点。它包含一个条件表达式（`ExpNode`）、一个`if`代码块（`BlockNode`）和一个`else`代码块（`BlockNode`）作为其成员变量。

```c++
class IfElseStmNode : public StmNode{
public:
    IfElseStmNode(ExpNode* _exp,BlockNode*_block,BlockNode*block_):exp(_exp),ifblock(_block),elseblock(block_){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    ExpNode *exp;
    BlockNode *ifblock,*elseblock;
};
```



#### WhileStmNode  

表示一个`while`循环语句，在语法树中的节点。它包含一个循环条件表达式（`ExpNode`）和一个代码块（`BlockNode`）作为其成员变量。

```c++
class WhileStmNode : public StmNode{
public:
    WhileStmNode(ExpNode* _exp,BlockNode*_block):exp(_exp),block(_block){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
    ExpNode *exp;
    BlockNode *block;
};
```



#### ForStmNode

表示一个`for`循环语句，在语法树中的节点。它包含一个循环条件表达式（`ExpNode`）和一个代码块（`BlockNode`）作为其成员变量。

```c++
class ForStmNode : public StmNode{
public:
    ForStmNode(ExpNode* _exp,BlockNode*_block):exp(_exp),block(_block){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);
    ExpNode *exp;
    BlockNode *block;
};
```



#### ReturnNullStmNode

表示一个不带返回值的`return`语句，在语法树中的节点。

```c++
class ReturnNullStmNode : public StmNode{
public:
    ReturnNullStmNode(){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

};
```



#### ReturnStmNode

表示一个带有返回值的`return`语句，在语法树中的节点。它包含一个返回值表达式（`ExpNode`）作为其成员变量。

```c++
class ReturnStmNode : public StmNode{
public:
    ReturnStmNode(ExpNode* _exp):exp(_exp){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    ExpNode *exp;
};
```



#### VarDecNode 

表示一个变量声明语句，在语法树中的节点。它包含一个类型标识符（`IdentifierNode`）、一个变量标识符（`IdentifierNode`）和可选的初始化表达式（`ExpNode`）作为其成员变量。

```c++
class VarDecNode : public StmNode{
public:
    VarDecNode(IdentifierNode* _type ,IdentifierNode* _identifier ):type(_type),identifier(_identifier){}
    VarDecNode(IdentifierNode* _type ,IdentifierNode* _identifier, int _size ):type(_type),identifier(_identifier),size(_size){}
    VarDecNode(IdentifierNode* _type ,IdentifierNode* _identifier, ExpNode* assign ):type(_type),identifier(_identifier),exp(assign){}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode *type;
    IdentifierNode *identifier;
    ExpNode* exp;
    int size;

};
```



#### FunDecNode 

表示一个函数声明语句，在语法树中的节点。它包含一个返回类型标识符（`IdentifierNode`）、一个函数标识符（`IdentifierNode`）、参数列表（`vector<VarDecNode*>`）和一个代码块（`BlockNode`）作为其成员变量。

```c++
class FunDecNode : public StmNode{
public:
    FunDecNode(IdentifierNode *_type, IdentifierNode *_identifier, 
    vector<VarDecNode*> _args, BlockNode *_block) :  type(_type), identifier(_identifier), args(_args), block(_block) {}
    virtual string genJson();
    virtual llvm::Value *genCode(CodeGenerator & gen);

    IdentifierNode *type;
    IdentifierNode *identifier;
    BlockNode *block;
    vector<VarDecNode*> args;
};
```



## CodeGenerator



储存生成中间代码的变量以及函数。

使用`symbol_Table`来作为符号表存储块内的变量表 local_var 及对应的变量-llvm 类型表 local_var_type。

CodeGenerator 类主要存储了一个符号栈，同时存有 LLVM::module 以及所定义的输入输出函数；

```c++
vector<symbolTable *> symbolTable_stack; 
llvm::Module *myModule; 
llvm::Function *printf,*scanf, *gets;
llvm::Function* currentFunc;
llvm::BasicBlock* returnBB;
llvm::Value* returnVal;
bool isArgs;
bool hasReturn;
```

同时定义了查找变量的函数`findVariable`

以及对`scanf`,`printf`,`gets`操作的函数

```c++
llvm::Function* getPrintf(); 
llvm::Function* getScanf(); 
llvm::Function* getGets(); 
llvm:: Value* emitScanf(CodeGenerator &emitContext,vector<ExpNode*> args);
llvm:: Value* emitPrintf(CodeGenerator &emitContext,vector<ExpNode*> args);
llvm:: Value* emitGets(CodeGenerator &emitContext,vector<ExpNode*> args);
vector<llvm::Value *> *getPrintfArgs(CodeGenerator &emitContext,vector<ExpNode*>args);
vector<llvm::Value *> *getScanfArgs(CodeGenerator &emitContext,vector<ExpNode*>args);
vector<llvm::Value *> *getGetsArgs(CodeGenerator &emitContext,vector<ExpNode*>args);
```





